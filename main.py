(lambda main:(lambda levels:(lambda **arguments: main(main, levels, **arguments['save_input'](arguments['save_print'](arguments['clear']("One String Sokoban\n\nw - up\na - left\ns - down\nd - right\nr - restart\ne - exit\n\nP - player\nB - box\n. - place\n# - wall\n\nPress Return to start..."), arguments))))))(lambda game_cycle, levels, **state: game_cycle(game_cycle, levels, **state['gc'](**state)) if not state['next_level_flag'] else(game_cycle(game_cycle,levels, **(state['change_level'](levels[state['next_level']], state))) if state["next_level"] != -1 else(input("Game Over!"))))([{'field_size':[7, 7], 'pers':[1, 1], 'boxes':[[2, 3], [3, 2]], 'walls':[[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [1, 0],[1, 4],[1, 6],[2, 0],[2, 4],[2, 6],[3, 0],[3, 6],[4, 0],[4, 6],[5, 0],[5, 6],[6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6]], 'places':[[1, 5], [2, 5]], 'current_level':0, 'next_level':1, }, { 'field_size':[9, 7], 'pers':[3, 1], 'boxes':[[3, 3], [3, 4], [3, 5]], 'walls':[[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [5, 0], [6, 0], [0, 1], [6, 1], [0, 2], [6, 2], [0, 3], [6, 3], [0, 4], [6, 4], [0, 5], [6, 5], [0, 6], [6, 6], [0, 7], [6, 7], [0, 8], [1, 8], [2, 8], [3, 8], [4, 8], [5, 8], [6, 8]], 'places':[[2, 7], [3, 7], [4, 7]], 'current_level': 1, 'next_level':2, }, { 'field_size':[9, 8], 'pers':[4, 1], 'boxes':[[3, 3], [5, 3], [2, 4]], 'walls':[[1, 0], [2, 0], [3, 0], [4, 0], [5, 0], [1, 1], [5, 1], [6, 1], [7, 1], [0, 2], [1, 2], [7, 2], [0, 3], [7, 3], [0, 4], [1, 4], [3, 4], [5, 4], [6, 4], [7, 4], [1, 5], [5, 5], [1, 6], [2, 6], [3, 6], [4, 6], [5, 6]], 'places':[[3, 2], [1, 3], [4, 3]], 'next_level':-1, 'current_level':2 },])(save_input=lambda arg:[arg, input()][0], change_level_tail=lambda fields, level, state:(state['update_state']('next_level_flag', False, **state) if len(fields) == 0 else state['change_level_tail'](fields[:-1], level, state["update_state"](fields[-1], level[fields[-1]], **state))), change_level=lambda level, state:(state["change_level_tail"](list(level.keys()), level, state)), current_level=-1, next_level=0, next_level_flag=True, print=lambda x, **state: [print(x), state][1], save_print=lambda x, y: [print(x), y][1], input=lambda x: input(x), field_size=[7, 7], pers=[1, 1], boxes=[[2, 3], [3, 2]], walls=[[0, 0],[0, 1],[0, 2],[0, 3], [0, 4], [0, 5], [0, 6], [1, 0], [1, 4], [1, 6], [2, 0], [2, 4], [2, 6], [3, 0], [3, 6], [4, 0], [4, 6], [5, 0], [5, 6], [6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6]], places=[[1, 5], [2, 5]], vectors={'w': [-1, 0], 's': [1, 0], 'd': [0, 1], 'a': [0, -1]}, vector_input=lambda inp, **state: state['vectors'][inp] if inp in state['vectors'].keys() else ([0, 0]), object_add_vector=lambda obj, vec: [obj[0] + vec[0], obj[1] + vec[1]], object_in_positions_test=lambda obj, pos: obj in pos, all_true_array_test=(lambda func: lambda states_list: func(func, states_list, True) )(lambda func, states_list, current_state: current_state if len(states_list) == 0 else func(func, states_list[:-1], current_state and states_list[-1])), equal_arrays=lambda arrx, arry, **state: state['all_true_array_test']((lambda x, y: [(i in y) for i in x])(arrx, arry)), mod_state_list=lambda key, value, **state: [{i: value} if key == i else {i: state[i]} for i in state.keys()], update_state_tail=lambda current_array, old_state, **new_state: old_state['update_state_tail'](current_array[:-1], old_state, **dict(list(new_state.items()) + list(current_array[-1].items()))) if len(current_array) != 0 else new_state, update_state=lambda key, value, **state: state['update_state_tail'](state['mod_state_list'](key, value, **state), state, **{}), win_test=lambda **state: None, clear=lambda arg: [__import__("os").system("cls" if __import__('os').name == "nt" else "clear"), arg][1], render=lambda **state: state['print'](state['clear']('\n'.join([''.join([ "#" if [i, o] in state['walls'] else ( "B" if [i, o] in state['boxes'] else ( "P" if [i, o] == state['pers'] else ( "." if [i, o] in state['places'] else " "))) for o in range(state['field_size'][0])]) for i in range(state['field_size'][1])])), **state), amount_in=lambda el, array: sum([1 if i == el else 0 for i in array]), one_box_collision_test=lambda vector, perss, boxess, key, **state: (state if state['object_add_vector'](vector, boxess[-1]) in state['walls'] or state['amount_in'](state['object_add_vector'](vector, boxess[-1]), state['boxes']) == 1 else state['update_state']( 'boxes', [state['object_add_vector'](i, vector) if key == len(state["boxes"])-i_key-1 else i for i_key, i in enumerate(state['boxes'], 0)], **state["update_state"]( 'pers', perss, **state))) if perss == boxess[-1] else state['one_box_collision_test'](vector, perss, boxess[:-1], key+1, **state), box_collision_test=lambda vector, perss, **state: state['one_box_collision_test'](vector, perss, state['boxes'], 0, **state), pers_collision_test=lambda vector, **state: state['box_collision_test'](vector, state['object_add_vector'](state['pers'], vector), **state) if state['object_add_vector'](state['pers'], vector) in state['boxes'] else (state if state['object_add_vector'](state['pers'], vector) in state['walls'] else (state['update_state']('pers', state['object_add_vector'](state['pers'], vector), **state))), post_input=lambda string, **state: state if len(string) == 0 else (exit() if string[-1] == "e" else (state['update_state']('next_level', state['current_level'], **state['update_state']('next_level_flag', True, **state)) if string[-1] == "r" else (state['post_input'](string[1:], **state['pers_collision_test'](state['vector_input'](string[0], **state), **state))))), wait_input=lambda trash, **state: state['post_input'](state['input'](":"), **state), player_win=lambda **state: True if not state['equal_arrays'](state["boxes"], state["places"], **state) else False, gc=lambda **state: state['wait_input'](state['render'](**state), **state) if state['player_win'](**state) else (state['update_state']('next_level_flag', True, **state)))